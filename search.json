[
  {
    "objectID": "04-plotting.html",
    "href": "04-plotting.html",
    "title": "R basics IV",
    "section": "",
    "text": "Our first plot\nIn the following, we will look at the gapminder dataset, which contains information on life expectancy and GDP per capita for more than 140 countries over a period of more than 50 years. Based on this data, we investigate the relationship between life expectancy and economic development across the world.\n\nlibrary(gapminder)\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nFor plotting, we use the ggplot2 package, which is contained in the tidyverse. The fundamental building block for any plot is a call to the ggplot() function, to which we pass the data that we want to plot. On its own, this just creates a blank plot, as we haven’t specified which variables we want to plot and how we want to plot them:\n\nlibrary(ggplot2)\n\np &lt;- ggplot(data = gapminder)\np\n\n\n\n\n\n\n\n\nTo do so, we have to specify an aesthetic mapping from our data variables to the visual elements of our plot (such as positions or colors). This allows us to specify that we want to display variation in GDP along the x-axis and life expectancy along the y-axis:\n\np &lt;- ggplot(data = gapminder,              \n            mapping = aes(x = gdpPercap, y = lifeExp))\np\n\n\n\n\n\n\n\n\nWe can see that our plot now contains axis labels and ticks informed by the range of the data, but there is still no visual representation of the data, because we haven’t specified what kind of plot we want.\nggplot operates in terms of layers which we can add to our basic plot specification with + to include specific geometric representations of our data (such as points in a scatterplot):\n\np + geom_point()\n\n\n\n\n\n\n\n\n\nggplot(data = gapminder, \n       mapping = aes(x = gdpPercap, y = lifeExp)) + \n  geom_point()\n\n\n\n\n\n\n\n\nAt this point we have a basic plot, which we can now customize to our heart’s content.\n\n\nExercises (20 mins)\nUse the jointly created code and add to it to solve the following tasks:\n\nChange the color of the points to blue.\n\n# Write your code here...\n\nMake the points transparent, so that it is easier to see overlapping data.\n\n# Write your code here...\n\nSpecify a log scale for GDP.\n\n# Write your code here...\n\nColor the points by continent.\n\n# Write your code here...\n\nAdd more readable labels to the plot.\n\n# Write your code here...\n\nAdd a title and a subtitle to the plot.\n\n# Write your code here...\n\nFind different plot themes and pick one.\n\n# Write your code here...\n\nMove the legend to the bottom of the plot.\n\n# Write your code here...\n\n\nAdd a regression line to the plot.\n\n\n# Write your code here...\n\nSave the plot as a .png file.\n\n# Write your code here...\n\nVisualize the population development by continent. Think about what you would want the plot to look like first and then identify the corresponding geom_*.\n\n# Write your code here...",
    "crumbs": [
      "`R` basics",
      "Data visualization"
    ]
  },
  {
    "objectID": "02-loading-data.html",
    "href": "02-loading-data.html",
    "title": "R Basics II",
    "section": "",
    "text": "The first step for any R analysis is getting data into an R session. While it sounds like this should be easy, data loading can be quite a hassle due to an unending variety of data formats, which are often only weakly specified. Due to this, data loading can be quite frustrating, especially when one is just getting started.\nNevertheless, there is a variety of packages which can help us with this step. Let’s try two of the most common formats:\n\n\nSometimes we want to send our data to a colleague, who might only be familiar with excel. So as a first step, we’re going to write the gapminder data to an excel spreadsheet. Let’s have a look at our data first:\n\nlibrary(gapminder)\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nWe can see that there’s 1704 rows (observations) and 6 columns (variables). Let’s write it to an excel file:\n\nlibrary(openxlsx)\n\nwrite.xlsx(gapminder,\n           file = \"data/gapminder.xlsx\",\n           colNames=TRUE)\n\nIn our working directory, there should now be the gapminder.xlsx file, containing a sheet with our data frame. There’s a variety of formatting options, but usually you should regard excel as a mere transport format and not as the final styled output.\nHaving created an excel file, we can also go the other way. Let’s read our data back into an R data.frame. For reading excel files, I would usually recommend the readxl package, which is part of the extended tidyverse:\n\nlibrary(readxl)\n\ndf &lt;- read_excel(\"data/gapminder.xlsx\")\ndf\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\nOne of the most wide-spread formats is .csv (for comma-separated values). It is a very simple and lightweight but also somewhat restrictive and underspecified format (e.g. regarding delimiter, headers, data types, sentinel values, etc.).\nWhile there’s a built-in function to read from csv, we’re again going to rely on the tidyverse here, which contains the readr package, providing this functionality.\n\nlibrary(readr)\n\nWe’ll follow the same procedure as before, first writing the gapminder data to a csv file and then reading it back again:\n\nwrite_csv(gapminder, file = \"data/gapminder.csv\")\n\nThere should now be a gapminder.csv file in your working directory, which you can also view with RStudio (click it in the file viewer).\nLet’s read it back in again:\n\ndf2 &lt;- read_csv(\"data/gapminder.csv\")\n\nRows: 1704 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): country, continent\ndbl (4): year, lifeExp, pop, gdpPercap\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndf2\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nWhen loading a csv file with read_csv, we get some information about the automatic detection of parsing specifications (e.g. the detected delimiter and column types).\n\n\n\n\nIdentify the data format of the file data.csv and find a function/package to load your data into R.\nIdentify the correct specification and arguments for loading your data and load your data into a data.frame.\n\n\nlibrary(readr)\ndata &lt;- read_csv2(\"data/data.csv\")\n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 100 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\nchr (1): name\ndbl (2): id, age\nnum (1): score\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "`R` basics",
      "Loading data"
    ]
  },
  {
    "objectID": "02-loading-data.html#exercises",
    "href": "02-loading-data.html#exercises",
    "title": "R Basics II",
    "section": "",
    "text": "Identify the data format of the file data.csv and find a function/package to load your data into R.\nIdentify the correct specification and arguments for loading your data and load your data into a data.frame.\n\n\nlibrary(readr)\ndata &lt;- read_csv2(\"data/data.csv\")\n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 100 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\nchr (1): name\ndbl (2): id, age\nnum (1): score\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "`R` basics",
      "Loading data"
    ]
  },
  {
    "objectID": "00-simple-example.html",
    "href": "00-simple-example.html",
    "title": "A simple network analysis in four lines of code",
    "section": "",
    "text": "The goal of this tutorial is to demonstrate how easy it is to do network analysis in R! It emulates the typical process of most analyses, starting at loading network data from a file and then moving on to computing some property of interest and finally to visualizing the result.\nThe document you’re looking at right now is a quarto markdown document (with the .qmd file extension), which allows us to combine (1) prose to explain and document what we are doing, (2) code to run our analysis, and (3) the output of our code, e.g. tables or visualizations.\nAny text you write in this document will be interpreted as prose, styled with markdown. If you want to include code, pressing the / key on your keyboard will show a popup dialogue which allows you to create a code cell in the programming language of your choice (in our case R):\n\n1 + 1 # the hashtag (#) creates a comment, which is not run by R.\n\n[1] 2\n\n\nIf you want to run the code in the cell, you can press the little green arrow symbol. This will show the output of the code below the cell.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#background",
    "href": "00-simple-example.html#background",
    "title": "A simple network analysis in four lines of code",
    "section": "",
    "text": "The goal of this tutorial is to demonstrate how easy it is to do network analysis in R! It emulates the typical process of most analyses, starting at loading network data from a file and then moving on to computing some property of interest and finally to visualizing the result.\nThe document you’re looking at right now is a quarto markdown document (with the .qmd file extension), which allows us to combine (1) prose to explain and document what we are doing, (2) code to run our analysis, and (3) the output of our code, e.g. tables or visualizations.\nAny text you write in this document will be interpreted as prose, styled with markdown. If you want to include code, pressing the / key on your keyboard will show a popup dialogue which allows you to create a code cell in the programming language of your choice (in our case R):\n\n1 + 1 # the hashtag (#) creates a comment, which is not run by R.\n\n[1] 2\n\n\nIf you want to run the code in the cell, you can press the little green arrow symbol. This will show the output of the code below the cell.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#step-0-loading-packages",
    "href": "00-simple-example.html#step-0-loading-packages",
    "title": "A simple network analysis in four lines of code",
    "section": "Step 0: Loading packages",
    "text": "Step 0: Loading packages\nR’s greatest strength is its ecosystem of packages. Packages (or libraries) extend the functionality provided by base R for a broad range of specific domains, such as network analysis. To load a package (e.g., the readr package to read a variety of file formats), we write library(package) in an R code cell.\n\nlibrary(readr)\n\nLoading a package requires us to have it installed first, which we can do with install.packages(\"readr\"). While we have to load the package each time we open a new R session, we only have to install it once. Because of this, you probably don’t want to include this code in a cell. What you can do instead, is copy-paste the install command into the R console and press enter. In RStudio, the console is by default located in the window below the quarto markdown document.\nFor this tutorial, we will also load the network and sna packages, which contain functionality to perform network analysis in R:\n\nlibrary(network)\n\n\n'network' 1.18.2 (2023-12-04), part of the Statnet Project\n* 'news(package=\"network\")' for changes since last version\n* 'citation(\"network\")' for citation information\n* 'https://statnet.org' for help, support, and other information\n\nlibrary(sna)\n\nLoading required package: statnet.common\n\n\n\nAttaching package: 'statnet.common'\n\n\nThe following objects are masked from 'package:base':\n\n    attr, order\n\n\nsna: Tools for Social Network Analysis\nVersion 2.7-2 created on 2023-12-05.\ncopyright (c) 2005, Carter T. Butts, University of California-Irvine\n For citation information, type citation(\"sna\").\n Type help(package=\"sna\") to get started.\n\n\nIf we haven’t installed the packages yet, we need to do so before we can load them, as described above.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#step-1-loading-data",
    "href": "00-simple-example.html#step-1-loading-data",
    "title": "A simple network analysis in four lines of code",
    "section": "Step 1: Loading data",
    "text": "Step 1: Loading data\nWith the readr package installed and loaded into our R session, we are now ready to load the data containing our network. Here, the network is represented by an edgelist (a specific kind of network data format which we will learn more about in the coming sessions) contained in a .csv file (a comma-separated-values file), which we could also look at in Excel or a text editor.\n\nedgelist &lt;- read_csv(\"data/edgelist.csv\")\n\nRows: 30 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (2): sender, receiver\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThere are multiple things going on in this one line of code:\n\nWe use the read_csv(…) function to load data from a .csv file\nWe pass the (relative) path to our .csv file as an argument to read_csv, in the \"string\" format\nWe assign the data read by the read_csv function to a variable named edgelist using the assignment operator &lt;-\n\nIf we look at the edgelist variable by clicking on it in the global environment viewer (top right), we see something very similar to an excel spreadsheet. Rectangular data containing many observations for multiple variables, such as typically contained in a spreadsheet, is in R represented by a data.frame.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#step-2-creating-a-network",
    "href": "00-simple-example.html#step-2-creating-a-network",
    "title": "A simple network analysis in four lines of code",
    "section": "Step 2: Creating a network",
    "text": "Step 2: Creating a network\nBy itself, R doesn’t know that it should treat the data in our edgelist data frame as representing a network. Accordingly, we convert our data.frame to a dedicated network object using the network(…) function, where we can also specify some properties of the network, such directedness:\n\nnet &lt;- network(edgelist, directed=FALSE)\n\nIf we just call this network object in a cell, it will show us a helpful summary of our network:\n\nnet\n\n Network attributes:\n  vertices = 10 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 30 \n    missing edges= 0 \n    non-missing edges= 30 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n\n\nThis output tells us, among other things, that our network contains 10 nodes and 30 edges.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#step-3-computing-centrality",
    "href": "00-simple-example.html#step-3-computing-centrality",
    "title": "A simple network analysis in four lines of code",
    "section": "Step 3: Computing centrality",
    "text": "Step 3: Computing centrality\nWe can now use a variety of functions on this network object to compute a broad range of quantities of interest, such as the degree centrality of each node (the node’s number of contacts):\n\ndeg &lt;- degree(net)\ndeg\n\n [1] 12 10 12 10 18 10 14 10 14 10\n\n\nThe result is a vector of values, where e.g. the first value tells us that the first node in the network has a total of 6 contacts.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#step-4-plotting-the-network",
    "href": "00-simple-example.html#step-4-plotting-the-network",
    "title": "A simple network analysis in four lines of code",
    "section": "Step 4: Plotting the network",
    "text": "Step 4: Plotting the network\nFinally, we may want to plot our network, labeling the nodes with their IDs and scaling the node size according to node degree. We can use the gplot(…) function to do so, passing a variety of arguments to control the display of labels, node color, or node size:\n\ngplot(net,\n      gmode=\"graph\",\n      label = 1:10,\n      label.pos = 5,\n      vertex.col=\"grey\",\n      vertex.cex=sqrt(deg))\n\n\n\n\n\n\n\n\nLooking at the plot, we can immediately see that node 5 is the most central, having a total of 9 connections to other nodes.",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-simple-example.html#putting-it-all-together",
    "href": "00-simple-example.html#putting-it-all-together",
    "title": "A simple network analysis in four lines of code",
    "section": "Putting it all together",
    "text": "Putting it all together\nAs promised, the above corresponds to a rudimentary network analysis in a total of four lines of code:\n\nedgelist &lt;- read_csv(\"data/edgelist.csv\") # read data from file\nnet &lt;- network(edgelist, directed=FALSE) # create network object \ndeg &lt;- degree(net) # compute degree centrality\ngplot(net, gmode=\"graph\",\n      label=1:10, label.pos=5, \n      vertex.col=\"grey\", vertex.cex=sqrt(deg)) # plot the network",
    "crumbs": [
      "Getting started",
      "A basic example"
    ]
  },
  {
    "objectID": "00-index.html",
    "href": "00-index.html",
    "title": "A first course in social network analysis with R",
    "section": "",
    "text": "This website accompanies the practical introduction to social network analysis with R taught at the LMU Department of Geography. The course is part of the Bachelor Degree module Special Anthropogeography and is usually taught in the summer term.\nThe course is targeted at students with limited programming experience. Accordingly, the first couple of sessions include a general introduction to some R programming concepts, without delving deeply into the fundamentals.",
    "crumbs": [
      "Getting started",
      "About this course"
    ]
  },
  {
    "objectID": "00-index.html#todo",
    "href": "00-index.html#todo",
    "title": "A first course in social network analysis with R",
    "section": "TODO",
    "text": "TODO\n\nCourse structure table\nFurther reading and resources",
    "crumbs": [
      "Getting started",
      "About this course"
    ]
  },
  {
    "objectID": "01-basics.html",
    "href": "01-basics.html",
    "title": "R Basics I",
    "section": "",
    "text": "Quarto notebooks\n\n\n\nAny applied project is an iterative process which involves a back-and-forth between writing code, looking at data and plots, and taking notes. This document is a Quarto notebook, which allows you to combine prose with code and code output, such as tables or plots, in one place.\nWe can compile this notebook to various output formats with the big blue Render button to produce nice-looking and reproducible reports.\nQuarto allows us to combine different programming languages in one environment. We can include a code chunk containing executable code by writing / in an empty line of the notebook.",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#variables",
    "href": "01-basics.html#variables",
    "title": "R Basics I",
    "section": "Variables",
    "text": "Variables\nTo assign a value to a name (a variable), in R you use the assignment operator &lt;-:\n\nx &lt;- 10 # this is a comment\n\nWe can now reference the value using the variable:\n\nx * 2\n\n[1] 20\n\n\nYou can assign arbitrary values to variables, not just numbers:\n\nname &lt;- \"Jakob\"\n\nHere, I assigned the string \"Jakob\" to the variable name. Strings are how R represents text and are constructed with quotation marks (\"...\").\nVariable names are case sensitive but cannot include spaces or special symbols, except for underscores (_) and period marks (.):\n\nthis is an invalid name &lt;- 1\nthis-too &lt;- 3\n\nError: &lt;text&gt;:1:6: unexpected symbol\n1: this is\n         ^\n\n\n\nbut_THIS_isnt &lt;- 5",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#functions",
    "href": "01-basics.html#functions",
    "title": "R Basics I",
    "section": "Functions",
    "text": "Functions\nTo perform any kind of operation, you use a function. E.g., to round a decimal number, we use the round function:\n\nround(3.14159)\n\n[1] 3\n\n\nFunctions can take inputs, called the arguments, which go into the parentheses right after the function name. Functions might also return some output, but they don’t have to. Most things you do in R will involve calling a function on some arguments and assigning the result to a variable name:\n\nIn R, arguments can be specified by name or by position, and often have default values:\n\nround(3.14159, digits=2)\n\n[1] 3.14\n\n\nYou can define your own functions, which can themselves call other functions:\n\ngreet &lt;- function(name) {\n  paste(\"Hello\", name)\n}\n\nHere, we defined a function called greet, which has an argument called name that takes in a string and returns a string with a greeting to the passed name. Let’s call it:\n\ngreet(name=\"Daniel\")\n\n[1] \"Hello Daniel\"\n\n\nNote that the name argument only exists as a referenceable variable within the scope of the function.\nWe can of course also call the function on a variable ‘storing’ a name:\n\ny &lt;- \"Daniel\"\ngreet(y)\n\n[1] \"Hello Daniel\"",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#exercises-i-10-15-min",
    "href": "01-basics.html#exercises-i-10-15-min",
    "title": "R Basics I",
    "section": "Exercises I (10-15 min)",
    "text": "Exercises I (10-15 min)\n\n\n\n\n\n\nGetting Help: ChatGPT & Co.\n\n\n\nProgramming frequently involves solving new problems for which you don’t know the solution yet. Luckily, most problems have been solved before by other people. Accordingly, many solutions to frequent problems can be found in a variety of places online.\nLarge Language Models (LLMs), such as ChatGPT, can be helpful in synthesizing these solutions. But be aware, “AI” tools are not all-knowing and will make mistakes or propose non-optimal solutions, just as the people they learned it from did.\nWith this in mind, the exercises we do here will frequently go beyond the contents we discussed before. This reflects the process of any real-world project and so will prepare you for pursuing your own research with R.\n\n\n\nAssign your name to a variable and call the greet(...) function on it which we defined before.\n\n# write your code here...\n\nCopy the greet() function from before, rename it to greet_spanish and change it so that it says Hola instead of Hello .\n\n# write your code here...\n\nCopy the greet() function again but this time change it so that it takes the greeting as a second function argument instead of specifying it in the function body.\n\n# write your code here...\n\nCreate a vector with the numbers from 1 to 100 and assign it to a variable called x.\n\n# write your code here...\n\nFind a function that sorts its input in reverse order and apply it to x.\n\n# write your code here...",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#vectors",
    "href": "01-basics.html#vectors",
    "title": "R Basics I",
    "section": "Vectors",
    "text": "Vectors\nThe most basic data structure in R is the vector. It contains elements of the same basic data type (e.g. numeric or character). We can create one with the c() function (for combine or concatenate):\n\nmy_vector &lt;- c(1,3,4,2)\nmy_vector\n\n[1] 1 3 4 2\n\n\nIn fact, even single numbers are just one-element vectors in R. Most operations in R ‘vectorize’, i.e. are applied element-wise:\n\nsqrt(my_vector)\n\n[1] 1.000000 1.732051 2.000000 1.414214\n\n\nor\n\nmy_vector == 2\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\nIndexing\nTo obtain a specific element from a vector we use square braces for an operation called indexing:\n\nmy_vector[2]\n\n[1] 3\n\n\nYou can also use another vector as an indexing variable:\n\nmy_idx &lt;- c(1,2,3)\nmy_vector[my_idx]\n\n[1] 1 3 4\n\nmy_vector[1:3]\n\n[1] 1 3 4",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#lists",
    "href": "01-basics.html#lists",
    "title": "R Basics I",
    "section": "Lists",
    "text": "Lists\nVectors have the constraint that all their elements need to have the same basic data type:\n\nc(\"f\", 1) # 1 is converted to string \n\n[1] \"f\" \"1\"\n\n\nA more flexible kind of container is the list, which allows you to store arbitrary data types, e.g.:\n\nmylist &lt;- list(\n    mynumber=1, \n    mystring=\"abc\", \n    mylist=list(x=1, b=\"a\")\n)\n\nYou can access the elements of a list with double square brackets:\n\nmylist[[2]]\n\n[1] \"abc\"\n\n\nYou can also access elements by name using the $ symbol, which is often preferable:\n\nmylist$mystring\n\n[1] \"abc\"\n\n\nYou can also add new elements to a list this way:\n\nmylist$newstring = \"xyz\"\nmylist\n\n$mynumber\n[1] 1\n\n$mystring\n[1] \"abc\"\n\n$mylist\n$mylist$x\n[1] 1\n\n$mylist$b\n[1] \"a\"\n\n\n$newstring\n[1] \"xyz\"",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#data-frames",
    "href": "01-basics.html#data-frames",
    "title": "R Basics I",
    "section": "Data frames",
    "text": "Data frames\nA special kind of list that is used to represent tabular data (as in an excel spreadsheet) is the data.frame. The elements of a data frame are the columns in the table. Columns are vectors, and thus have to hold elements of the same basic data type (e.g. numbers) and are constrained to be the same length:\n\ndf &lt;- data.frame(\n  name = c(\"Tim\", \"Tom\", \"Tina\"),\n  age = c(21, 23, 24),\n  subject = c(\"Geography\", \"Economics\", \"Physics\")\n)\n\ndf\n\n  name age   subject\n1  Tim  21 Geography\n2  Tom  23 Economics\n3 Tina  24   Physics\n\n\nTo access the columns of a data frame, we can again use the $ symbol, as with regular lists:\n\ndf$subject\n\n[1] \"Geography\" \"Economics\" \"Physics\"  \n\n\nData frames are the bread-and-butter data structure of most regular data analysis projects, so you should get comfortable with them.",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "01-basics.html#exercises-ii-10-15-min",
    "href": "01-basics.html#exercises-ii-10-15-min",
    "title": "R Basics I",
    "section": "Exercises II (10-15 min)",
    "text": "Exercises II (10-15 min)\n\n\n\n\n\n\nPackages\n\n\n\nWhile R comes ‘batteries included’ in many regards, much of the functionality that makes R useful is located in packages. We load a package with the library function.\nIf we try to load a package which has not yet been installed, RStudio will prompt us to install it. Alternatively, we can install a package via install.packages(\"stringr\") (note the quotes).\nIf you put install.packages(\"...\") into a code cell, you should probably delete it after running to avoid reinstalling packages everytime you run the notebook. Instead you can also install your packages via the console.\n\n\n\nWhat is wrong with this piece of code? Find the errors and fix them.\n\nmydf &lt;- data.frame(\n  country &lt;- (\"Germany\", \"France\", \"Austria\"),\n  capital &lt;- c(\"Berlin\", \"Paris\"),\n  gdp &lt;- c(4.12, 2.80 0.48)\n\nError: &lt;text&gt;:2:24: unexpected ','\n1: mydf &lt;- data.frame(\n2:   country &lt;- (\"Germany\",\n                          ^\n\n\nSample 10 numbers from a normal distribution with mean 0 and standard deviation 2 and assign them to a variable called s.\n\n# write your code here...\n\nCompute the empirical mean and the standard deviation of the numbers in s.\n\n# write your code here...\n\nFind the minimum and the maximum value of s programmatically.\n\n# write your code here...\n\nWhat are the indexes of the minimum and maximum value?\n\n# write your code here...\n\n\n\n\nFind (the indexes of) all values in s that are larger than 0:\n\n# write your code here...\n\n\n\n\nSplit the following string at the comma to produce a vector of three strings:\n\nnames &lt;- \"Tim,Tom,Tina\"\n\n\n\n\nHere is a slightly more complex piece of code. What is each line here doing?\n\nlibrary(ggplot2)\n\ndata &lt;- data.frame(\n  group = rep(c(\"A\", \"B\", \"C\"), each = 50),\n  value = c(rnorm(50, mean = 10, sd = 2), \n            rnorm(50, mean = 12, sd = 2),\n            rnorm(50, mean = 15, sd = 2))\n)\n\nggplot(data, aes(x = group, y = value)) +\n  geom_boxplot() +\n  labs(title = \"Boxplot Example\", x = \"Group\", y = \"Value\")",
    "crumbs": [
      "`R` basics",
      "Variables and functions"
    ]
  },
  {
    "objectID": "03-data-handling.html",
    "href": "03-data-handling.html",
    "title": "R basics III",
    "section": "",
    "text": "Data wrangling refers to all the steps that need to be taken before the actual analysis can be conducted. As such, it is often considered a nuisance that however usually takes a considerable share of the overall effort and code in a research project.\nData wrangling comprises, e.g., filtering out bad data, selecting a subset of available data, reshaping data into a more useful format, or computing derivative measures and summaries. In the following, we will look at some of the most frequently needed operations and how to apply them using the tidyverse.\nWe will again do so using the gapminder dataset:\n\nlibrary(gapminder)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\nOftentimes, we’re only interested in a subset of the observations contained in our data. Say, for example, we only want data on Germany since the 1990s. We can use the filter function to achieve this:\n\nfilter(gapminder, country == \"Germany\", year &gt;= 1990)\n\n# A tibble: 4 × 6\n  country continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Germany Europe     1992    76.1 80597764    26505.\n2 Germany Europe     1997    77.3 82011073    27789.\n3 Germany Europe     2002    78.7 82350671    30036.\n4 Germany Europe     2007    79.4 82400996    32170.\n\n\n\n\n\nSimilarly, we’re often only interested in a subset of the variables. We can use the select command to select only some variables and also to rename them:\n\nselect(gapminder, country, year, life_expectancy=lifeExp)\n\n# A tibble: 1,704 × 3\n   country      year life_expectancy\n   &lt;fct&gt;       &lt;int&gt;           &lt;dbl&gt;\n 1 Afghanistan  1952            28.8\n 2 Afghanistan  1957            30.3\n 3 Afghanistan  1962            32.0\n 4 Afghanistan  1967            34.0\n 5 Afghanistan  1972            36.1\n 6 Afghanistan  1977            38.4\n 7 Afghanistan  1982            39.9\n 8 Afghanistan  1987            40.8\n 9 Afghanistan  1992            41.7\n10 Afghanistan  1997            41.8\n# ℹ 1,694 more rows\n\n\n\n\n\nOften, we want to group our data according to one variable (e.g., the continent) and then compute a summary for each of the groups based on another variable (e.g., the mean life expectancy). We can do this by first creating a grouped version of our data using group_by and then using summarize to compute a summary for each group:\n\ndata_grouped &lt;- group_by(gapminder, continent)\nsummarize(data_grouped, lifeExp_mean = mean(lifeExp))\n\n# A tibble: 5 × 2\n  continent lifeExp_mean\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n\n\nNote that this drops all other variables except for the grouping variable and the summary variable.\n\n\n\nTypically, data wrangling implies combining multiple of these steps. R allows us to build data pipelines with the pipe operator |&gt; which pipes the output of the operation to the left into the first argument of the operation to the right. Instead of writing filter(data, year &gt; 1990) we could for example write data |&gt; filter(year &gt; 1990).\n\nfilter(gapminder, year &gt; 1990)\n\n# A tibble: 568 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1992    41.7 16317921      649.\n 2 Afghanistan Asia       1997    41.8 22227415      635.\n 3 Afghanistan Asia       2002    42.1 25268405      727.\n 4 Afghanistan Asia       2007    43.8 31889923      975.\n 5 Albania     Europe     1992    71.6  3326498     2497.\n 6 Albania     Europe     1997    73.0  3428038     3193.\n 7 Albania     Europe     2002    75.7  3508512     4604.\n 8 Albania     Europe     2007    76.4  3600523     5937.\n 9 Algeria     Africa     1992    67.7 26298373     5023.\n10 Algeria     Africa     1997    69.2 29072015     4797.\n# ℹ 558 more rows\n\n\nOn its own, this is not very useful. However, this syntax allows us to chain multiple operations from left to right or from top to bottom, which is easier to read than nested functions. consider for example the following:\n\nselect(filter(gapminder, year &gt; 1990, country == \"Germany\"), year, lifeExp)\n\n# A tibble: 4 × 2\n   year lifeExp\n  &lt;int&gt;   &lt;dbl&gt;\n1  1992    76.1\n2  1997    77.3\n3  2002    78.7\n4  2007    79.4\n\n# is equivalent to\n\ngapminder |&gt;\n  filter(year &gt; 1990, country == \"Germany\") |&gt;\n  select(year, lifeExp)\n\n# A tibble: 4 × 2\n   year lifeExp\n  &lt;int&gt;   &lt;dbl&gt;\n1  1992    76.1\n2  1997    77.3\n3  2002    78.7\n4  2007    79.4\n\n\n\n\n\n\nBuild a data pipeline that computes the mean life expectancy and the mean per-capita GDP in Europe for each 5-year period since the 1980s.\n\n\nReshape the gapminder data into a country-by-year matrix, i.e., a data frame where each row is a country, each column is a year and each cell contains the GDP for that country-year pair.\n\n\n# Write your code here...\n\n\nHow many entries in gapminder are from after 1960 and come from OECD countries?\nHere’s a list of all countries in the OECD: “Australia”, “Austria”, “Belgium”, “Canada”, “Chile”, “Colombia”, “Costa Rica”, “Czech Republic”, “Denmark”, “Estonia”, “Finland”, “France”, “Germany”, “Greece”, “Hungary”, “Iceland”, “Ireland”, “Israel”, “Italy”, “Japan”, “Korea”, “Latvia”, “Lithuania”, “Luxembourg”, “Mexico”, “Netherlands”, “New Zealand”, “Norway”, “Poland”, “Portugal”, “Slovak Republic”, “Slovenia”, “Spain”, “Sweden”, “Switzerland”, “Turkey”, “United Kingdom”, “United States”\n\n\n# Write your code here...",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  },
  {
    "objectID": "03-data-handling.html#filtering-rows",
    "href": "03-data-handling.html#filtering-rows",
    "title": "R basics III",
    "section": "",
    "text": "Oftentimes, we’re only interested in a subset of the observations contained in our data. Say, for example, we only want data on Germany since the 1990s. We can use the filter function to achieve this:\n\nfilter(gapminder, country == \"Germany\", year &gt;= 1990)\n\n# A tibble: 4 × 6\n  country continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Germany Europe     1992    76.1 80597764    26505.\n2 Germany Europe     1997    77.3 82011073    27789.\n3 Germany Europe     2002    78.7 82350671    30036.\n4 Germany Europe     2007    79.4 82400996    32170.",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  },
  {
    "objectID": "03-data-handling.html#selecting-and-renaming-variables",
    "href": "03-data-handling.html#selecting-and-renaming-variables",
    "title": "R basics III",
    "section": "",
    "text": "Similarly, we’re often only interested in a subset of the variables. We can use the select command to select only some variables and also to rename them:\n\nselect(gapminder, country, year, life_expectancy=lifeExp)\n\n# A tibble: 1,704 × 3\n   country      year life_expectancy\n   &lt;fct&gt;       &lt;int&gt;           &lt;dbl&gt;\n 1 Afghanistan  1952            28.8\n 2 Afghanistan  1957            30.3\n 3 Afghanistan  1962            32.0\n 4 Afghanistan  1967            34.0\n 5 Afghanistan  1972            36.1\n 6 Afghanistan  1977            38.4\n 7 Afghanistan  1982            39.9\n 8 Afghanistan  1987            40.8\n 9 Afghanistan  1992            41.7\n10 Afghanistan  1997            41.8\n# ℹ 1,694 more rows",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  },
  {
    "objectID": "03-data-handling.html#group-summaries",
    "href": "03-data-handling.html#group-summaries",
    "title": "R basics III",
    "section": "",
    "text": "Often, we want to group our data according to one variable (e.g., the continent) and then compute a summary for each of the groups based on another variable (e.g., the mean life expectancy). We can do this by first creating a grouped version of our data using group_by and then using summarize to compute a summary for each group:\n\ndata_grouped &lt;- group_by(gapminder, continent)\nsummarize(data_grouped, lifeExp_mean = mean(lifeExp))\n\n# A tibble: 5 × 2\n  continent lifeExp_mean\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n\n\nNote that this drops all other variables except for the grouping variable and the summary variable.",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  },
  {
    "objectID": "03-data-handling.html#data-pipelines",
    "href": "03-data-handling.html#data-pipelines",
    "title": "R basics III",
    "section": "",
    "text": "Typically, data wrangling implies combining multiple of these steps. R allows us to build data pipelines with the pipe operator |&gt; which pipes the output of the operation to the left into the first argument of the operation to the right. Instead of writing filter(data, year &gt; 1990) we could for example write data |&gt; filter(year &gt; 1990).\n\nfilter(gapminder, year &gt; 1990)\n\n# A tibble: 568 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1992    41.7 16317921      649.\n 2 Afghanistan Asia       1997    41.8 22227415      635.\n 3 Afghanistan Asia       2002    42.1 25268405      727.\n 4 Afghanistan Asia       2007    43.8 31889923      975.\n 5 Albania     Europe     1992    71.6  3326498     2497.\n 6 Albania     Europe     1997    73.0  3428038     3193.\n 7 Albania     Europe     2002    75.7  3508512     4604.\n 8 Albania     Europe     2007    76.4  3600523     5937.\n 9 Algeria     Africa     1992    67.7 26298373     5023.\n10 Algeria     Africa     1997    69.2 29072015     4797.\n# ℹ 558 more rows\n\n\nOn its own, this is not very useful. However, this syntax allows us to chain multiple operations from left to right or from top to bottom, which is easier to read than nested functions. consider for example the following:\n\nselect(filter(gapminder, year &gt; 1990, country == \"Germany\"), year, lifeExp)\n\n# A tibble: 4 × 2\n   year lifeExp\n  &lt;int&gt;   &lt;dbl&gt;\n1  1992    76.1\n2  1997    77.3\n3  2002    78.7\n4  2007    79.4\n\n# is equivalent to\n\ngapminder |&gt;\n  filter(year &gt; 1990, country == \"Germany\") |&gt;\n  select(year, lifeExp)\n\n# A tibble: 4 × 2\n   year lifeExp\n  &lt;int&gt;   &lt;dbl&gt;\n1  1992    76.1\n2  1997    77.3\n3  2002    78.7\n4  2007    79.4",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  },
  {
    "objectID": "03-data-handling.html#exercises",
    "href": "03-data-handling.html#exercises",
    "title": "R basics III",
    "section": "",
    "text": "Build a data pipeline that computes the mean life expectancy and the mean per-capita GDP in Europe for each 5-year period since the 1980s.\n\n\nReshape the gapminder data into a country-by-year matrix, i.e., a data frame where each row is a country, each column is a year and each cell contains the GDP for that country-year pair.\n\n\n# Write your code here...\n\n\nHow many entries in gapminder are from after 1960 and come from OECD countries?\nHere’s a list of all countries in the OECD: “Australia”, “Austria”, “Belgium”, “Canada”, “Chile”, “Colombia”, “Costa Rica”, “Czech Republic”, “Denmark”, “Estonia”, “Finland”, “France”, “Germany”, “Greece”, “Hungary”, “Iceland”, “Ireland”, “Israel”, “Italy”, “Japan”, “Korea”, “Latvia”, “Lithuania”, “Luxembourg”, “Mexico”, “Netherlands”, “New Zealand”, “Norway”, “Poland”, “Portugal”, “Slovak Republic”, “Slovenia”, “Spain”, “Sweden”, “Switzerland”, “Turkey”, “United Kingdom”, “United States”\n\n\n# Write your code here...",
    "crumbs": [
      "`R` basics",
      "Data wrangling"
    ]
  }
]